; list already defined in Machine

(def
 cons (fn* cons [x seq] (. AjSharpure.Operations Cons x seq)))

;during bootstrap we don't have destructuring let, loop or fn, will redefine later
(def
 #^{:macro true}
  let (fn* let [& decl] (cons 'let* decl)))

(def
 #^{:macro true}
 loop (fn* loop [& decl] (cons 'loop* decl)))

(def
 #^{:macro true}
 fn (fn* fn [& decl] (cons 'fn* decl)))

(def
 #^{:arglists '([coll])
    :doc "Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil."}
 first (fn first [coll] (. AjSharpure.Operations (First coll))))

(def
 #^{:arglists '([coll])
    :tag clojure.lang.ISeq
    :doc "Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil."}  
 next (fn next [x] (. AjSharpure.Operations (Next x))))

(def
 #^{:arglists '([coll])
    :tag clojure.lang.ISeq
    :doc "Returns a possibly empty seq of the items after the first. Calls seq on its
  argument."}  
 rest (fn rest [x] (. AjSharpure.Operations (More x))))

(= (rest (list 1 2 3)) '(2 3))

(def
 #^{:arglists '([coll x] [coll x & xs])
    :doc "conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type."}
 conj (fn conj 
        ([coll x] (. AjSharpure.Operations (Conj coll x)))
        ([coll x & xs]
         (if xs
           (recur (conj coll x) (first xs) (next xs))
           (conj coll x)))))
           
(= (list 1 2 3 4) (conj (list 2 3 4) 1))
(= [1 2 3 4] (conj [1 2 3] 4))

(def
 #^{:doc "Same as (first (next x))"
    :arglists '([x])}
 second (fn second [x] (first (next x))))

(= (list 1 2 3) (cons 1 (list 2 3)))
(= 1 (first (list 1 2 3)))
(= 2 (second (list 1 2 3)))

(= 1 (first [1 2 3]))
(= 2 (second [1 2 3]))

(def
 #^{:doc "Same as (first (first x))"
    :arglists '([x])}
 ffirst (fn ffirst [x] (first (first x))))

(= 1 (ffirst (list (list 1) 2 3)))

(= 1 (ffirst [[1] 2 3]))

(def
 #^{:doc "Same as (next (first x))"
    :arglists '([x])}
 nfirst (fn nfirst [x] (next (first x))))

(= (list 2) (nfirst (list (list 1 2) 2 3)))

(= [2] (nfirst [[1 2] 2 3]))

(def
 #^{:doc "Same as (first (next x))"
    :arglists '([x])}
 fnext (fn fnext [x] (first (next x))))

(= 2 (fnext (list 1 2 3)))

(= 2 (fnext [1 2 3]))

(def
 #^{:doc "Same as (next (next x))"
    :arglists '([x])}
 nnext (fn nnext [x] (next (next x))))

(= (list 3) (nnext (list 1 2 3)))

(= [3] (nnext [1 2 3]))

(def
 #^{:arglists '([coll])
    :doc "Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable."
    :tag clojure.lang.ISeq}
 seq (fn seq [coll] (. AjSharpure.Operations (ToSequence coll))))

(= '(1 2 3) (seq (list 1 2 3)))

(= '(1 2 3) (seq [1 2 3]))

(def
 #^{:arglists '([#^Class c x])
    :doc "Evaluates x and tests if it is an instance of the class
    c. Returns true or false"}
 instance? (fn instance? [#^Class c x] (. c (IsInstanceOfType x))))
 
(instance? System.Int32 18)
 
(def
 #^{:arglists '([x])
    :doc "Return true if x implements ISeq"}
 seq? (fn seq? [x] (instance? AjSharpure.Language.ISequence x)))

(seq? (seq (list 1 2 3)))

(def
 #^{:arglists '([x])
    :doc "Return true if x is a String"}
 string? (fn string? [x] (instance? System.String x)))

(string? "foo")

(def
 #^{:arglists '([x])
    :doc "Return true if x implements IPersistentMap"}
 map? (fn map? [x] (instance? AjSharpure.Language.IPersistentMap x)))

(def
 #^{:arglists '([x])
    :doc "Return true if x implements IPersistentVector "}
 vector? (fn vector? [x] (instance? AjSharpure.Language.IPersistentVector x)))
 
(vector? [1 2 3])

(vector? (vector 1 2 3))
 
(def
 #^{:private true}
 sigs
 (fn [fdecl]
   (if (seq? (first fdecl))
     (loop [ret [] fdecl fdecl]
       (if fdecl
         (recur (conj ret (first (first fdecl))) (next fdecl))
         (seq ret)))
     (list (first fdecl)))))

(def
 #^{:arglists '([map key val] [map key val & kvs])
    :doc "assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."}
 assoc
 (fn assoc
   ([map key val] (. AjSharpure.Language.Operations (Associate map key val)))
   ([map key val & kvs]
    (let [ret (assoc map key val)]
      (if kvs
        (recur ret (first kvs) (second kvs) (nnext kvs))
        ret)))))

; TODO 
; (assoc {:a 1 :b 2} :c 3)



